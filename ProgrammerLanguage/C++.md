# C++ issues  
## 保留字
### static
- 修饰范围：变量、指针、引用、函数参数、函数返回值
- 作用域：函数、类、文件、命名空间、全局  
- 生命周期：初始化后，整个程序一直存在
- 存储区域：静态内存
- 作用：可以通过类直接访问，共享内存，延长局部变量生命周期，类的静态成员函数不含this指针
### const  
- 修饰范围：常量、指针、引用、函数参数、函数返回值
- 作用域：函数、类、文件、命名空间、全局
- 作用：只读，需要初始化
- 存储区域： 
- 生命周期：整个程序一直存在
### external  
- 修饰范围：变量，函数
- 作用：修饰变量，表示修饰对象已经在其他地方声明了，修饰对象一定是全局变量
- 与static的区别：external是给外部使用，只需要声明，static是为自己声明，只需要定义
- extern "C" 是为了能够使C++正确调用C语言代码；
### volatile
- 修饰范围：变量
- 作用：阻止编译的代码优化，即使用volatile变量时，都会从内存中读取，而不是从寄存器中，但是不能保证线程安
全；
- 使用情况：
    - 中断程序中对变量进行修改时，如volatile变量已经赋值为1，然后发生中断，中断程序中，修改volatile变量为2，此时中断程序结束，恢复现场，那么volatile变量的值为2，而不是1；
    - 同理，多任务环境下，各个任务共享一个变量时，也需要定义为volatile，保证每次取到的值都是最新的版本而不是缓存在寄存器中的旧版本；
    - 存储器映射的硬件寄存器通常也是需要定义为volatile的；
- 编译优化时，可能将变量读取到寄存器，方便读取，但是这个变量很可能被其他线程修改，因为每次都需要从内存中读取最新版本；

### explicit/implicit

### 四种转型操作  
- C++的四种转型方式：
    - const_cast<T>: 常量转除，即将const转为非const
    - dynamic_cast<T>: 安全向下转型，效率差，因为很可能要进行许多class名字的strcmp操作
    - reinterpret_cast<T>: 低级转型，如pointer to int转型为int，可移植性差，不同编译器实现不同
    - static_cast<T>: 强迫隐式转换，如将non-const转换为const，或int转double，但是无法将const转non-const

## 引用
### 左值引用
### 右值引用

## 智能指针
理解：构造对象在生命周期结束之后会调用析构函数，而指针对象在生命周期结束之后不会主动调用析构函数，需要手动delete；
### auto_ptr
- auto_ptr<T> : 简单封装一个T类型的指针，重载了*和->运算符；
- 常用操作：
    - get(); 
    - release();
    - reset(); 
- 缺点：
1.不能共享所有权，即赋值和复制都是危险操作；
2.由于不能共享所有权，因为在STL中使用风险很大；
3.不支持对象数组内存管理，即auto_ptr<T[]> 是非法的；

- C++11后建议不要再使用auto_ptr，而使用unique_ptr替代  
### unique_ptr
- 理解：类似auto_ptr，但是存在某些特殊约束：
1. 无法进行左值复制或赋值操作，但允许临时的右值复制构造和赋值（使用std::move）；
2. 允许在STL中使用，并禁止直接赋值，当然可以使用std::move来赋值；
3. 支持对象数组的内存管理， unique_ptr<T[]> 是合法的，会自动调用delete[]去释放内存；
4. 除了以上约束，unique_ptr还支持自定义析构，如 unique_ptr<T, D>，其中D是一个自定义的析构器；  

- 注意，unique_ptr只是auto_ptr的扩展，并在语义上禁止了auto_ptr可能的危险操作，但它仍是排他性指针，不能共享所有权；  
### shared_ptr  
- 理解：通过引用计数来共享所有权，即赋值或拷贝时，被引用的内存对象引用计数加1，而智能指针析构时，引用计数减1，当引用计数为0时，就可以释放内存了  
- use_count(); 获取指针指向内存的引用个数；
- make_shard<T>(); 推荐用来构造一个shared_ptr指针，内存分配效率更高；

- 缺点：循环引用导致会导致shared_ptr造成内存泄漏；

### weak_ptr  
- 理解：配合shared_ptr使用，可以从一个shared_ptr或者weak_ptr对象构造，但是它的构造和析构不会改变引用计数；
- lock(); 获取一个shared_ptr对象，注意weak_ptr没有重载*和->运算符，因此不能直接访问引用对象；
- expired(); weak_ptr中也会维护use_count，当weak_ptr托管对象时，返回false，否则返回true；

## \#define

## 内存管理  
### 构造函数、拷贝构造函数、移动构造函数、析构函数
- 拷贝构造函数和移动构造函数
    - 参数：拷贝构造函数参数一般是一个常左值引用（const ObjectType&），移动构造函数的参数一般是右值引用（ObjectType&&）
    - 拷贝构造函数的意义在于获取对象的一份独立数据；移动构造函数则是将当前对象的内容转移给另一个对象，相当于延长了临时对象的声明周期，可以减少拷贝次数；
    - 当对象满足以下条件时，编译器会优先选择移动构造函数：
        - 对象是右值，即将消亡的对象或std::move()转化成的右值；
        - 对象的资源是可移动的；
        - 对象拷贝成本高，但是移动成本低；
    - 构造函数被调用调用的情况：
        - 用一个对象初始化另一个对象；
        - 传递一个对象作为参数到函数中；
        - 从函数中返回一个对象；
    - 移动构造函数被调用的情况：
        - 从一个临时对象创建一个新对象；
        - 将一个临时对象作为参数传递到函数中；
        - 从函数中返回一个临时对象；
### 函数重载、重写、隐藏与覆盖
- 重载：同一作用域， 同一函数名，参数不同；
- 隐藏：不同作用域，同一函数名，参数不同；
- 重写：虚函数继承，重写就是覆盖；
- 协变返回类型：虚函数继承中，返回值是子类重写的函数返回的指针或引用是父类中被重写函数返回指针或引用的子类型；
### 内联函数与宏定义的区别和联系
- 都可以理解为代码展开，减少函数调用带来的开销（保存现场，压栈弹栈，恢复现场）；
- 宏定义发生在预编译，内联发生的编译时期，内敛函数是真正的函数，会做类型安全检查和自动类型转换；
- 宏定义无法调用C++私有成员，内联函数可以；
- 内联函数会进符号表；
### 数组与指针的区别和联系：
- 都可以用来指示相同或兼容类型的连续空间；
- 指针是指向这个空间，而数组就代表这个空间；
- 数值存储在栈上，指针所指的空间一般在堆上，指针空间需要额外回收；
- 数组的sizeof返回数组空间大小，指针的sizeof返回机器地址的大小；
- 在函数传参时，数组退化为指针；
### 浅拷贝和深拷贝
### 类占用内存的计算方式、空类的空间大小
### 虚函数及其原理
### 内存泄漏出现的时机和原因，如何避免  
### new和delete，以及它们与malloc和free的区别  
### C++内存划分  
- 划分区域：全局区、堆区、栈区、常量区、代码区

## C++11新特性
### 智能指针  
### auto关键字  
### lambda表达式  
### override关键字  
### 右值引用  

## C++ STL
### STL的六大部件和联系  
### STL原理  
### 哈希结构的原理  
### STL各大算法

## 模板编程  
### 泛化 
### 全特化  
### 偏特化  


## 编译过程  
### 编译阶段  
### 动态链接库和静态链接库  
- 都是程序扩展；
- 静态链接库理解为#include，将代码直接扩展在源文件中，即生成的目标代码时包含静态链接库的，动态链接则只是引用接口，实际的代码在运行时加载，因此程序运行时是需要动态链接库的，而不需要静态链接库；
### 指针和引用的区别  
### 宏
### null和nullptr的区别  


