# Operation System
## 进程和线程
### 进程概念基础
- 概念：计算机资源分配的基本单位  
- 状态：创建、终止、挂起、激活、阻塞、唤醒，和各个状态之间的转换  
### 进程与线程的区别：
- 进程是资源分配的基本单位，包括可执行代码、文件描述符、挂起的信号、进程状态、内存空间、全局数据段、以及若干个线程；而线程是进程中活动的对象，或者独立调度的基本单位，线程有独立的程序计数器、线程退栈和寄存器；

- 为什么需要线程：
    - 因为一个进程可能有多个需要调度的任务，如果没有线程，那么其中一个任务阻塞时，其他任务都会阻塞，但是线程的存在解决了这个问题，进程可以给每个任务分配一个线程，当其中一个任务阻塞时，该进程并没有阻塞，只是这个任务对应的线程会阻塞，其他线程正常作业；
    - 线程更轻量，更快的创建和销毁，线程之间切换的开销也比进程小，进程的切换需要保存当前进程的所有资源，而线程的切换只需要保存当前堆栈和少量寄存器的内容；

### 什么是协程？协程有什么优点？
- 协程是用户态的轻量级线程，协程切换只需要保留cpu的信息（寄存器、PC、栈顶指针），而且完全在用户空间进行，速度极快，不涉及内核资源的保存和恢复；

### 并发和并行
- 并发：一段时间可以运行多个程序，即单核多线程；
- 并行：同一时刻可以运行多个程序，即多核多线程，是真正意义上的并发；

### 进程间通信方式和特点？
- 进程间的通信方式和特点：
    - 管道：父子进程
    - 命名管道：去除父子进程的通信机制，可以汇聚多个客户端进程和服务端进程；
    - 消息队列：独立与进程存在，进程间可以通过消息队列来传递数据，如生产者-消费者模型；
    - 信号：一个进程可以给另一个进程发送信号来触发某些操作，如挂起一个进程；
    - 信号量：计数器，用来保护临界资源，进程可以读取这个信号量，并对它进行加减；
    - 共享内存：多个进程上不同的地址空间可以映射到同一个物理内存上，实现数据共享，要注意同步和独占；
    - Socket通信：通过网络实现不同机器上不同进程间的通信；

### 僵尸进程和孤儿进程的区别？
- 僵尸进程：子进程退出，但是进程描述符没有释放，需要父进程调用wait()或者waitpid()获取子进程信息后，再决定是否释放子进程的资源。但如果子进程资源一直得不到释放，就会变成僵尸进程；
- 孤儿进程：父进程退出，但是子进程没有退出；但是孤儿进程是暂时的，父进程退出后，系统会为子进程寻找新的父进程；
- 系统中有大量僵尸进程时，造成成资源的浪费，解决办法是直接杀死父进程，这样子进程会变成孤儿进程，再由新的父线程来决定子进程的资源释放；

### 进程是怎么调度的？
- 批处理：保证吞吐量和总体响应时间，调度算法有：
    - FCFS：先来先服务
    - 短作业优先：贪心策略，先调度耗时最短的进程；
    - 最短剩余时间优先：贪心策略，按作业的最短剩余时间调度。新作业会与当前作业的最短剩余时间比较，如果小于当前作业的剩余运行时间，则挂起当前作业，运行新的作业；（但大部分情况下不知道作业需要多久运行结束）

- 交互式系统：与用户交互性强，需要保证较短的响应时间，满足用户期望，调度算法有：
    - 时间片轮转调度：即所有进程享有公平的调度，比如将CPU时间分成12份，那么每个进程等待12份CPU时间后就能响应，绝对公平，但是需要频繁切换进程上下文，系统开销很大；
    - 优先级调度：每个进程标识一个优先级，重要的进程享受更多的CPU时间；
    - 多级队列：设立多个优先级队列，即第一级的进程获取1个CPU时间片，若没执行完，则放到下一个队列，并获取更多的CPU时间片，以此类推；

- 实时系统：又分软实时和硬实时，前者能容忍一定延迟，后者需要满足绝对截止时间。  

### 进程有几种状态，他们是如何转换的？
- 状态：运行、就绪、阻塞  
- 运行态和就绪态可以相互转换，通常由系统的进程调度引起。
- 当运行中的进程遇到阻塞代码时，需要等待触发条件，并被挂起，进入阻塞状态，当条件满足时，再转换到就绪状态；  

### 进程和线程的创建方式？  
- 进程创建：
    - 系统启动时，会初始化3个进程，idle进程（PID=0），init进程（PID=1），页面守护进程（PID=2）；
    - 运行中的进程创建子进程，如fork命令；
    - 用户请求创建一个新进程，比如通过shell命令；
    - 提交一个批处理请求，会创建一个新进程来运行；

### 子进程创建时会拷贝父进程哪些资源？
- 写时拷贝：Linux系统中，子进程的创建不会马上拷贝父进程的所有资源，而是只读的方式共享父进程的大部分资源，当需要修改资源时，触发只读保护，这是才会拷贝一份地址空间。
- fork只是为子进程创建唯一的进程标识符，分配一个有效的PID；

### 进程上下文切换和线程上下文切换
- 上下文切换：当前任务资源（寄存器、PC）、状态等内容保存起来，加载新的任务，同时更新PC，然后继续执行；
- 进程上下文切换：
    - 用户空间：虚拟内存、全局变量、文件描述符等；
    - 内核空间：堆栈、寄存器、PC；
- 线程上下文切换：只需要保存线程堆栈和寄存器内容；

### 什么是系统调用？为什么要有系统调用？
- 系统调用：进程中，用户态切内核态，在内核中执行任务，或申请操作系统的资源。
- 系统调用是一种保护操作系统的机制，它提供了一系列定义良好的接口来实现用于与操作系统的交互，避免用户直接对内核进行操作，保证了系统的稳定、安全、可靠。  

### 内核态和用户态是什么？
- 内核态：可以调度操作系统所有资源，如内存、I/O等；
- 用户态：只能访问受限的资源，如虚拟内存、全局变量等，同时可以触发系统调用来间接调度内核态；
- 一般，CPU有一个程序状态字（PSW）来控制内核态和用户态；

### 如何实现进程同步？  
- 只有临界区（共享内存的代码片段）的进程才需要同步。
- 进程同步的方式：
    - 忙等待互斥：一直询问变量，直到满足条件。忙等待的锁成为自旋锁。 自旋锁一般用于处理中断程序，因为中断程序需要安全、快速的执行，且不能被打断、也不能被睡眠。
    - 信号量：一个int变量，提供down和up操作，两个操作都是原子的，当down操作是信号量为0时，才会导致当前进程睡眠，而up操作，会唤醒一个进程。
    - 管程：管程是由一个过程、变量和数据结构组成的集合，把需要控制的那部分代码独立出来，管程的一个重要特性是同一时刻在管程中只有一个活跃的进程。放了防止某个进程一直占用管程，引入条件变量wait和signal，wait用于阻塞当前无法运行的进程，signal用于唤醒正在睡眠的进程，然后马上退出管程。

### 生产者消费者问题
- 也叫有界缓冲区问题，即两个进程共享一个公共的固定大小的缓冲区，一个进程产生数据放到缓冲区，另一个进程从缓冲区取走信息。这里存在对计数变量的竞争条件。  

### 什么是信号量？如何使用信号量解决生产者消费者问题？
- 信号量是一个int变量，用来实现计数功能。提供原子性的down和up操作。
- 当信号量只取0和1时，就是一个互斥信号量，取值大于1时，就是计数信号量。

### 哲学家就餐问题？
- 问题：5个哲学家围着一张圆桌，每个哲学家面前放着食物，哲学家有两种操作：进餐和思考。当一个哲学家进餐时，需要先拿起自己左右两边的叉子，并且以此只能拿起一只叉子。5个哲学家最多只能同时两人进餐，因为只有5只叉子。如果5个哲学家同时拿起左边的叉子，那么都在等待邻居放下右边的叉子，导致谁都无法进餐，产生饥饿（死锁）。
- 为了避免思索，需要：
    - 必须同时拿起左右两边的叉子  
    - 只有在两个邻居都没有进餐的情况下才允许进餐

### 读者-写者问题？
- 问题：允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。
- 解决：
    - count记录进行读操作的进程数量；
    - count_mutex对count进行加锁处理；
    - data_mutex用于对数据进行加锁处理；

### 死锁条件和解决方案
- 死锁原因：
    - 系统资源不足；
    - 资源分配不当；
    - 进程运行推进的顺序不合适；
- 死锁条件：
    - 互斥条件：多个线程不能同时使用同一个资源；
    - 持有并等待条件：线程1持有A资源，线程2持有B资源，但是线程1又需要B资源；
    - 不可剥夺条件：当前线程已经有个资源，但是没使用完之前不能被其他线程获取；
    - 环路等待条件：若干个线程需要的资源顺序构成环形链；


## 内存管理  

## 文件管理  

## 设备管理  